import math
from pathlib import Path
from typing import TYPE_CHECKING, Callable, Iterator

import cairosvg
import pytest
from syrupy.assertion import SnapshotAssertion
from syrupy.extensions.single_file import SingleFileAmberSnapshotExtension

import braile_art
import lesson_2_passage_conan
import lesson_3_examples_1
import lesson_3_examples_3
import lesson_3_examples_4
import lesson_4_examples_1
from draw import (
    EventRecorder,
    Page,
    Turtle,
    draw_sentence,
    draw_word,
    split_into_chunks,
)
from draw_jupyturtle import DrawingContext


def words_from_text(text: list[str]) -> set[str]:
    return {word for line in text for word in line.split()}


def words_from_words(words: list[tuple[str, str]]) -> set[str]:
    return {spelling for _, spelling in words}


WORDBANK: set[str] = set()
WORDBANK.update(words_from_text(lesson_2_passage_conan.text))
WORDBANK.update(words_from_words(lesson_3_examples_1.words))
WORDBANK.update(words_from_words(lesson_3_examples_3.words))
WORDBANK.update(words_from_text(lesson_3_examples_4.text_combined))
WORDBANK.update(words_from_text(lesson_4_examples_1.text))


# Mock Turtle implementation adhering to the Turtle Protocol
class MockTurtle(Turtle):
    def __init__(self):
        self._x = 0.0
        self._y = 0.0
        self._heading = 0.0
        self._pen_color = "#000000"
        self.is_pen_down = True
        # Log high-level actions relevant for testing draw_word logic
        self.log: list[tuple] = []

    @property
    def x(self) -> float:
        return self._x

    @property
    def y(self) -> float:
        return self._y

    @property
    def heading(self) -> float:
        return self._heading

    @heading.setter
    def heading(self, value: float) -> None:
        self._heading = value
        # self.log.append(("set_heading", round(value, 2))) # Less relevant for draw_word logic

    @property
    def pen_color(self) -> str:
        return self._pen_color

    @pen_color.setter
    def pen_color(self, value: str) -> None:
        self._pen_color = value
        # self.log.append(("set_pen_color", value)) # Less relevant

    def forward(self, distance: float) -> None:
        # Simplified movement, primarily for state tracking if needed,
        # but draw_word logic focuses on higher-level events.
        rad = -math.radians(self._heading)  # Turtle heading is clockwise, math is CCW
        dx = distance * math.cos(rad)
        dy = distance * math.sin(rad)
        new_x = self._x + dx
        new_y = self._y + dy
        # self.log.append(("forward", round(distance, 2), f"to ({round(new_x, 2)}, {round(new_y, 2)})"))
        self._x = new_x
        self._y = new_y

    def jump_to(self, x: float, y: float) -> None:
        self._x = x
        self._y = y
        self.log.append(("jump_to", round(x, 2), round(y, 2)))

    def move_to(self, x: float, y: float) -> None:
        # Treat move_to like jump_to for logging purposes in this mock
        self._x = x
        self._y = y
        self.log.append(("move_to", round(x, 2), round(y, 2)))

    def pen_up(self) -> None:
        if self.is_pen_down:
            self.is_pen_down = False
            self.log.append(("pen_up",))

    def pen_down(self) -> None:
        if not self.is_pen_down:
            self.is_pen_down = True
            self.log.append(("pen_down",))


@pytest.mark.parametrize(
    "word",
    WORDBANK,
)
def test_draw_word_events(snapshot: SnapshotAssertion, word: str):
    """Test the sequence of high-level events generated by draw_word."""
    mock_turtle = MockTurtle()
    # Consistent starting page state for predictable results
    page = Page(
        vowel_area_height_px=20,
        current_line_bottom_px=100,
        current_line_left_px=50,
        furthest_from_left_px=50,  # Initialize based on current_line_left_px
        furthest_from_top_px=100,  # Initialize based on current_line_bottom_px
    )
    event_recorder = EventRecorder()

    # Execute the function under test
    draw_word(mock_turtle, page, word, event_recorder)

    # Snapshot the recorded high-level events (draw_glyph, advance_after_glyph)
    assert event_recorder.events == snapshot


from syrupy.terminal import (
    received_style,
    snapshot_style,
)

if TYPE_CHECKING:
    from syrupy.types import (
        SerializedData,
    )


class FullTextDiff(SingleFileAmberSnapshotExtension):
    def __format_line(
        self,
        line: str,
        line_style: Callable[[str], str],
    ) -> str:
        line = line.rstrip("".join(self._ends.keys()))
        return "".join(line_style(char) for char in line)

    def diff_lines(
        self, serialized_data: "SerializedData", snapshot_data: "SerializedData"
    ) -> Iterator[str]:
        for line in str(snapshot_data).splitlines():
            yield self.__format_line(line, snapshot_style)
        for line in str(serialized_data).splitlines():
            yield self.__format_line(line, received_style)


@pytest.fixture
def snapshot_fulltext(snapshot: SnapshotAssertion):
    return snapshot.use_extension(FullTextDiff)


@pytest.mark.parametrize(
    "word, expected_chunks",
    [
        ("fire", ["f", "ir", "e"]),
        ("mount", ["m", "ount"]),
        ("s$(TR)ength", ["s$(TR)", "ength"]),
        # Add more test cases
        ("", []),  # Empty string edge case
        ("a", ["a"]),  # Single vowel
        ("b", ["b"]),  # Single consonant
        ("aeiou", ["a", "e", "i", "o", "u"]),  # All vowels
        ("bcdfg", ["bcdfg"]),  # All consonants
        ("$(TR)eat", ["$(TR)", "eat"]),  # Glyph at start
        ("h$(ING)", ["h$(ING)"]),  # Glyph at end
        ("yu", ["y", "u"]),  # Two consecutive vowels
    ],
)
def test_split_into_chunks(word: str, expected_chunks: list[str]):
    """Test the split_into_chunks function with various inputs."""
    assert split_into_chunks(word) == expected_chunks


@pytest.mark.parametrize(
    "line_index, line_text",
    enumerate(
        lesson_2_passage_conan.text + lesson_3_examples_4.text_combined + lesson_4_examples_1.text
    ),
)
def test_draw_sentence_braille_snapshot(
    snapshot_fulltext: SnapshotAssertion, tmp_path: Path, line_index: int, line_text: str
):
    """
    Test drawing a sentence, converting to SVG -> PNG -> Braille,
    and comparing against snapshot.
    """
    svg_path = tmp_path / f"line_{line_index}.svg"
    png_path = tmp_path / f"line_{line_index}.png"

    # 1. Draw sentence and generate SVG
    # Use DrawingContext similar to lesson_2_passage_conan.py
    dc = DrawingContext(
        output_path=svg_path,
        drawing_width=750,  # Match the original script
        drawing_height=150,  # Match the original script
    )
    with dc as (p, t):
        draw_sentence(t, p, line_text)

    # 2. Convert SVG to PNG
    cairosvg.svg2png(url=str(svg_path), write_to=str(png_path))

    # 3. Convert PNG to Braille and chunk
    braille_chunks = braile_art.chunk_braile(braile_art.image_to_braille(png_path), 120)

    # 4. Compare each Braille chunk against snapshot
    for i, chunk_lines in enumerate(braille_chunks):
        braille_output = "\n".join(chunk_lines)
        # Syrupy automatically indexes snapshots for multiple asserts in one test
        assert braille_output == snapshot_fulltext(name=f"chunk_{i}")
